## Coward AI - Flee on contact, avoid combat at all costs
## Full speed retreat, only fight if cornered

var WEAPON_RANGE: float = 10.0
var SAFE_DISTANCE: float = 100.0  # Try to maintain this distance
var PANIC_HULL_THRESHOLD: float = 0.8  # Panic at 80% hull!

print('[COWARD AI] Initializing evasive AI (PID %d)' % pid)
print('[COWARD AI] FLEE PROTOCOL ACTIVE')

var loop_count = 0
var max_loops = 100

while loop_count < max_loops:
	loop_count += 1

	# Step 1: Check our status - PANIC CHECK
	var status_fd = kernel.sys_open(pid, '/proc/ship/status', kernel.O_RDONLY)
	if status_fd < 0:
		print('[COWARD AI] ERROR: Cannot read ship status')
		return -1

	var status_data = kernel.sys_read(pid, status_fd, 4096)
	kernel.sys_close(pid, status_fd)
	var status_str = status_data.get_string_from_utf8()

	var hull_current = 0.0
	var hull_max = 0.0
	var shields_current = 0.0

	var status_lines = status_str.split("\n")
	for line in status_lines:
		if "Hull:" in line:
			var parts = line.split(":")
			if parts.size() >= 2:
				var values = parts[1].strip_edges().split("/")
				if values.size() >= 2:
					hull_current = values[0].to_float()
					hull_max = values[1].to_float()
		elif "Shields:" in line:
			var parts = line.split(":")
			if parts.size() >= 2:
				var values = parts[1].strip_edges().split("/")
				if values.size() >= 1:
					shields_current = values[0].to_float()

	var hull_percent = hull_current / hull_max if hull_max > 0 else 0.0

	# Step 2: COWARD POWER ALLOCATION - Engines for speed, shields for survival
	var power_fd = kernel.sys_open(pid, '/dev/ship/actions/power', kernel.O_WRONLY)
	if power_fd >= 0:
		if hull_percent < 0.5:
			# EXTREME PANIC - ALL SHIELDS
			print('[COWARD AI] PANIC MODE - ALL SHIELDS!')
			kernel.sys_write(pid, power_fd, "Shields:3,Engines:1,Weapons:0".to_utf8_buffer())
		elif hull_percent < PANIC_HULL_THRESHOLD:
			# Panicking - shields and engines
			print('[COWARD AI] Taking damage - defensive retreat!')
			kernel.sys_write(pid, power_fd, "Shields:2,Engines:2,Weapons:0".to_utf8_buffer())
		else:
			# Default coward - engines to run, minimal weapons
			print('[COWARD AI] Evasive power allocation')
			kernel.sys_write(pid, power_fd, "Engines:3,Shields:1,Weapons:0".to_utf8_buffer())
		kernel.sys_close(pid, power_fd)

	# Step 3: Check for threats
	var sensors_fd = kernel.sys_open(pid, '/proc/ship/sensors', kernel.O_RDONLY)
	if sensors_fd < 0:
		print('[COWARD AI] ERROR: Cannot access sensors')
		return -1

	var sensors_data = kernel.sys_read(pid, sensors_fd, 4096)
	kernel.sys_close(pid, sensors_fd)
	var sensors_str = sensors_data.get_string_from_utf8()

	# Step 4: Check if enemies are nearby
	var enemy_detected = false
	var closest_distance = 999.0
	var threat_name = ""

	var lines = sensors_str.split("\n")
	for line in lines:
		if line.contains(":") and line.contains("units"):
			enemy_detected = true
			var parts = line.split(":")
			if parts.size() >= 2:
				threat_name = parts[0].strip_edges()
				var dist_part = parts[1].strip_edges()
				if " units" in dist_part:
					var dist_str = dist_part.split(" ")[0]
					var dist = dist_str.to_float()
					if dist < closest_distance:
						closest_distance = dist

	# Step 5: FLEE if enemies detected
	if enemy_detected:
		print('[COWARD AI] ENEMY DETECTED: %s at %.1f units!' % [threat_name, closest_distance])

		if closest_distance < SAFE_DISTANCE:
			print('[COWARD AI] TOO CLOSE - FLEEING AT FULL SPEED!')

			# FLEE: Thrust backward (away from threat)
			var thrust_fd = kernel.sys_open(pid, '/dev/ship/actions/thrust', kernel.O_WRONLY)
			if thrust_fd >= 0:
				kernel.sys_write(pid, thrust_fd, "backward".to_utf8_buffer())
				kernel.sys_close(pid, thrust_fd)

			# Turn toward target (keep eyes on threat while fleeing)
			# First set target for turn_direction to work
			if threat_name != "":
				var target_write_fd_flee = kernel.sys_open(pid, '/dev/ship/target', kernel.O_WRONLY)
				if target_write_fd_flee >= 0:
					kernel.sys_write(pid, target_write_fd_flee, threat_name.to_utf8_buffer())
					kernel.sys_close(pid, target_write_fd_flee)

			var turn_dir_fd = kernel.sys_open(pid, '/proc/ship/turn_direction', kernel.O_RDONLY)
			if turn_dir_fd >= 0:
				var turn_data = kernel.sys_read(pid, turn_dir_fd, 1024)
				kernel.sys_close(pid, turn_dir_fd)
				var turn_str = turn_data.get_string_from_utf8()

				# Parse Turn command from output
				var turn_lines = turn_str.split("\n")
				for line in turn_lines:
					if "Turn:" in line:
						var turn_parts = line.split(":")
						if turn_parts.size() >= 2:
							var turn_cmd = turn_parts[1].strip_edges()
							print('[COWARD AI] Turning: %s (while fleeing)' % turn_cmd)

							var turn_fd = kernel.sys_open(pid, '/dev/ship/actions/turn', kernel.O_WRONLY)
							if turn_fd >= 0:
								kernel.sys_write(pid, turn_fd, turn_cmd.to_utf8_buffer())
								kernel.sys_close(pid, turn_fd)
							break

			# Also use jump as emergency escape if really close
			if closest_distance < 30.0:
				print('[COWARD AI] EMERGENCY JUMP!')
				var pos_fd = kernel.sys_open(pid, '/proc/ship/position', kernel.O_RDONLY)
				if pos_fd >= 0:
					var pos_data = kernel.sys_read(pid, pos_fd, 1024)
					kernel.sys_close(pid, pos_fd)
					var pos_str = pos_data.get_string_from_utf8()

					var current_pos = 0.0
					var pos_lines = pos_str.split("\n")
					for line in pos_lines:
						if "Position:" in line:
							var pos_parts = line.split(":")
							if pos_parts.size() >= 2:
								current_pos = pos_parts[1].strip_edges().to_float()
								break

					var flee_target = current_pos + 50.0
					var jump_fd = kernel.sys_open(pid, '/dev/ship/actions/jump', kernel.O_WRONLY)
					if jump_fd >= 0:
						kernel.sys_write(pid, jump_fd, str(flee_target).to_utf8_buffer())
						kernel.sys_close(pid, jump_fd)
		else:
			print('[COWARD AI] Enemy at safe distance (%.1f >= %.1f) - maintaining distance' % [closest_distance, SAFE_DISTANCE])
			# Stop fleeing if far enough
			var thrust_fd = kernel.sys_open(pid, '/dev/ship/actions/thrust', kernel.O_WRONLY)
			if thrust_fd >= 0:
				kernel.sys_write(pid, thrust_fd, "stop".to_utf8_buffer())
				kernel.sys_close(pid, thrust_fd)

	# Step 6: Only fight if CORNERED (very close range, can't escape)
	if closest_distance < WEAPON_RANGE and closest_distance >= 0:
		print('[COWARD AI] CORNERED - Fighting back in desperation!')

		# Acquire target if needed
		var target_fd = kernel.sys_open(pid, '/dev/ship/target', kernel.O_RDONLY)
		if target_fd >= 0:
			var target_data = kernel.sys_read(pid, target_fd, 1024)
			kernel.sys_close(pid, target_fd)
			var target_str = target_data.get_string_from_utf8()

			if "No target selected" in target_str and threat_name != "":
				print('[COWARD AI] Targeting closest threat: %s' % threat_name)
				var target_write_fd = kernel.sys_open(pid, '/dev/ship/target', kernel.O_WRONLY)
				if target_write_fd >= 0:
					kernel.sys_write(pid, target_write_fd, threat_name.to_utf8_buffer())
					kernel.sys_close(pid, target_write_fd)

			# Fire any ready weapon (desperation shot)
			var weapons_fd = kernel.sys_open(pid, '/proc/ship/weapons', kernel.O_RDONLY)
			if weapons_fd >= 0:
				var weapons_data = kernel.sys_read(pid, weapons_fd, 4096)
				kernel.sys_close(pid, weapons_fd)
				var weapons_str = weapons_data.get_string_from_utf8()

				var weapon_lines = weapons_str.split("\n")
				for line in weapon_lines:
					if "READY" in line and line.contains("["):
						var bracket_start = line.find("[")
						var bracket_end = line.find("]")
						if bracket_start >= 0 and bracket_end > bracket_start:
							var weapon_idx_str = line.substr(bracket_start + 1, bracket_end - bracket_start - 1)
							var weapon_idx = weapon_idx_str.to_int()

							print('[COWARD AI] Desperation shot - weapon %d!' % weapon_idx)
							var fire_fd = kernel.sys_open(pid, '/dev/ship/actions/fire', kernel.O_WRONLY)
							if fire_fd >= 0:
								kernel.sys_write(pid, fire_fd, str(weapon_idx).to_utf8_buffer())
								kernel.sys_close(pid, fire_fd)
							break  # Fire only one, then try to flee again
	else:
		print('[COWARD AI] No immediate threats - staying alert')

	# For testing, break after one cycle
	break

print('[COWARD AI] Evasion cycle complete')
return 0
